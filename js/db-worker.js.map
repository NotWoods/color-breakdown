{"version":3,"file":"db-worker.js","sources":["../../node_modules/idb/build/esm/chunk.js","../../node_modules/idb/build/esm/index.js","../../src/db-worker/process-entry.ts","../../src/db-worker/examples.ts","../../src/db-worker/db.ts","../../src/revoke-object-url.ts","../../src/db-worker/handle-message.ts","../../src/db-worker/index.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then(value => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', event => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking) {\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking)).catch(() => { });\r\n    }\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string')) {\r\n        return;\r\n    }\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName))) {\r\n        return;\r\n    }\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import { HistoryEntry, PaletteEntry } from '../entry';\n\n/**\n * Convert Data URI representing an image into a blob with the same data.\n * @see https://stackoverflow.com/questions/12168909/blob-from-dataurl\n */\nexport function dataUriToBlob(dataUri: string) {\n    const [header, data] = dataUri.split(',', 2);\n\n    // separate out the mime component\n    const mimeType = header.split(':', 2)[1].split(';', 1)[0];\n    // convert base64 to raw binary data held in a string\n    const byteString = atob(data);\n\n    // write the bytes of the string to an ArrayBuffer\n    const buffer = new ArrayBuffer(byteString.length);\n    const intBuffer = new Uint8Array(buffer); // create a view into the buffer\n    for (let i = 0; i < byteString.length; i++) {\n        intBuffer[i] = byteString.charCodeAt(i);\n    }\n\n    return new Blob([buffer], { type: mimeType });\n}\n\n/**\n * Convert blob to data uri\n * @throws DOMException if error when reading\n */\nexport function blobToDataUri(blob: Blob) {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result as string);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(blob);\n    });\n}\n\nexport function processEntry(entry: HistoryEntry): PaletteEntry;\nexport function processEntry(entry: undefined): undefined;\nexport function processEntry(\n    entry: HistoryEntry | undefined,\n): PaletteEntry | undefined;\nexport function processEntry(\n    entry: HistoryEntry | undefined,\n): PaletteEntry | undefined {\n    if (entry == undefined) {\n        return undefined;\n    }\n    const timestamp = entry.id as number;\n    const imgBlob = dataUriToBlob(entry.imgSrc);\n    return {\n        timestamp,\n        imgSrc: URL.createObjectURL(imgBlob),\n        colors: entry.colors,\n        name: entry.name || new Date(timestamp).toLocaleString(),\n    };\n}\n","import { PaletteEntry } from '../entry';\n\nconst white = '#FFFFFF';\nconst black = '#000000';\n\nconst example1: PaletteEntry = {\n    timestamp: 1,\n    imgSrc: 'img/demo/andrew-hughes-261571-unsplash.jpg',\n    name: 'Photo by Andrew Hughes on Unsplash',\n    colors: {\n        vibrant: { color: '#AE340E', textColor: white },\n        darkVibrant: { color: '#6C140C', textColor: white },\n        lightVibrant: { color: '#DACC9B', textColor: black },\n        muted: { color: '#9F805F', textColor: white },\n        darkMuted: { color: '#3B3945', textColor: white },\n        lightMuted: { color: '#DAD3B0', textColor: black },\n    },\n};\n\nconst example2: PaletteEntry = {\n    timestamp: 2,\n    imgSrc: 'img/demo/ever-wild-634729-unsplash.jpg',\n    name: 'Photo by ever wild on Unsplash',\n    colors: {\n        vibrant: { color: '#FBA409', textColor: black },\n        darkVibrant: { color: '#7C0404', textColor: white },\n        lightVibrant: { color: '#F9A250', textColor: black },\n        muted: { color: '#AC784C', textColor: white },\n        darkMuted: { color: '#8C6C44', textColor: white },\n        lightMuted: { color: '#BC987A', textColor: black },\n    },\n};\n\nconst example3: PaletteEntry = {\n    timestamp: 3,\n    imgSrc: 'img/demo/will-turner-1244879-unsplash.jpg',\n    name: 'Photo by Will Turner on Unsplash',\n    colors: {\n        vibrant: { color: '#1E8EE0', textColor: white },\n        darkVibrant: { color: '#061C2C', textColor: white },\n        lightVibrant: { color: '#8AC4EF', textColor: black },\n        muted: { color: '#777C80', textColor: white },\n        darkMuted: { color: '#253D4C', textColor: white },\n        lightMuted: { color: '#BBBCC4', textColor: black },\n    },\n};\n\nexport const EXAMPLES = new Map([\n    [1, example1],\n    [2, example2],\n    [3, example3],\n]);\n","import { DBSchema, openDB } from 'idb';\nimport { HistoryEntry, PaletteEntry } from '../entry';\nimport { revokeIfObjectUrl } from '../revoke-object-url';\nimport { blobToDataUri, processEntry } from './process-entry';\nimport { EXAMPLES } from './examples';\n\ninterface ColorBreakdownDBSchema extends DBSchema {\n    history: {\n        key: number;\n        value: HistoryEntry;\n    };\n    example: {\n        key: number;\n        value: {\n            readonly id: number;\n            readonly hidden: true;\n        };\n    };\n}\n\nexport const dbPromise = openDB<ColorBreakdownDBSchema>('history-store', 2, {\n    upgrade(db, oldVersion) {\n        switch (oldVersion) {\n            case 0:\n                db.createObjectStore('history', { keyPath: 'id' });\n            // fall through\n            case 1:\n                db.createObjectStore('example', { keyPath: 'id' });\n            // fall through\n        }\n    },\n});\n\n/**\n * Loads a single history item for the main palette viewer\n */\nexport async function loadItemFromDB(\n    timestamp: number,\n): Promise<PaletteEntry | undefined> {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        const info = await db.get('example', timestamp);\n        const hidden = info?.hidden || false;\n        return hidden ? undefined : EXAMPLES.get(timestamp) || undefined;\n    } else {\n        const item = await db.get('history', timestamp);\n        return processEntry(item);\n    }\n}\n\nexport async function openFirstItem(): Promise<PaletteEntry | undefined> {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    const historyItems = await tx.objectStore('history').getAll(undefined, 1);\n    if (historyItems.length > 0) {\n        return processEntry(historyItems[0]);\n    }\n\n    const exampleEntries = await tx.objectStore('example').getAll();\n    const hiddenExamples = new Set(\n        exampleEntries.filter((item) => item.hidden).map((item) => item.id),\n    );\n    const visibleExample = Array.from(EXAMPLES.values()).find(\n        (example) => !hiddenExamples.has(example.timestamp),\n    );\n    return visibleExample || undefined;\n}\n\n/**\n * Delete a history item with the given timestamp\n */\nexport async function deleteItemFromDB(timestamp: number) {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        await db.put('example', { id: timestamp, hidden: true });\n    } else {\n        await db.delete('history', timestamp);\n    }\n}\n\n/**\n * Load the history list.\n * @param callback Called on each iteration.\n */\nexport async function loadHistoryFromDB(\n    exampleCb: (id: number) => void,\n    historyCb: (entry: PaletteEntry) => void,\n) {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    await Promise.all([\n        tx\n            .objectStore('example')\n            .openCursor()\n            .then(async (cursor) => {\n                while (cursor) {\n                    if (cursor.value.hidden) {\n                        exampleCb(cursor.key);\n                    }\n                    cursor = await cursor.continue();\n                }\n            }),\n        tx\n            .objectStore('history')\n            .openCursor()\n            .then(async (cursor) => {\n                while (cursor) {\n                    historyCb(processEntry(cursor.value)!);\n                    cursor = await cursor.continue();\n                }\n            }),\n    ]);\n}\n\n/**\n * Save items to the database.\n * Items may have object URLs as `imgSrc` properties, and will be processed\n * into data URIs.\n */\nexport async function saveItemsToDB(\n    items: ReadonlyArray<PaletteEntry>,\n): Promise<HistoryEntry[]> {\n    // Need to process entries first due to IDB restrictions\n    const entries = await Promise.all(\n        items.map(async (item) => {\n            const blob = await fetch(item.imgSrc).then((r) => r.blob());\n            const dataUri = await blobToDataUri(blob);\n            revokeIfObjectUrl(item.imgSrc);\n            return {\n                id: item.timestamp,\n                imgSrc: dataUri,\n                colors: item.colors,\n                name: item.name,\n            };\n        }),\n    );\n\n    const db = await dbPromise;\n    const { store, done } = await db.transaction('history', 'readwrite');\n    entries.forEach((entry) => store.put(entry));\n    await done;\n\n    return entries;\n}\n","/**\n * Revoke a url if it is an object url.\n */\nexport function revokeIfObjectUrl(url: string) {\n    if (new URL(url).protocol === 'blob:') {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * When used as an `onload` listener for an image, this function will\n * revoke the image's source object url if it is an object url.\n */\nexport function revokeObjectUrlOnLoad(evt: Event) {\n    const img = evt.target as HTMLImageElement;\n    revokeIfObjectUrl(img.src);\n}\n","import { HistoryEntry, PaletteEntry } from '../entry';\nimport { UiAction } from '../page/handle-message';\nimport {\n    deleteItemFromDB,\n    loadHistoryFromDB,\n    loadItemFromDB,\n    openFirstItem,\n    saveItemsToDB,\n} from './db';\nimport { processEntry } from './process-entry';\n\ninterface SaveAction {\n    readonly type: 'SAVE';\n    readonly payload: ReadonlyArray<PaletteEntry>;\n}\n\ninterface LoadAction {\n    readonly type: 'LOAD';\n    readonly payload: undefined;\n}\n\ninterface OpenAction {\n    readonly type: 'OPEN';\n    readonly payload: {\n        readonly timestamp: number;\n        readonly firstLoad: boolean;\n    };\n}\n\ninterface DeleteAction {\n    readonly type: 'DELETE';\n    readonly payload: {\n        readonly timestamp: number;\n        readonly current: boolean;\n    };\n}\n\nexport type WorkerAction = SaveAction | LoadAction | OpenAction | DeleteAction;\ntype ProcessEntryFunc = (entry: HistoryEntry) => PaletteEntry;\n\nexport async function handleMessage(\n    action: WorkerAction,\n    postMessage: (msg: UiAction) => void,\n) {\n    console.log(action.type, action.payload);\n    try {\n        switch (action.type) {\n            case 'SAVE':\n                if (action.payload.length > 0) {\n                    const entries = await saveItemsToDB(action.payload);\n                    postMessage({\n                        type: 'DISPLAY',\n                        payload: {\n                            entry: processEntry(entries[0]),\n                            firstLoad: false,\n                            updateHash: true,\n                        },\n                    });\n                    postMessage({\n                        type: 'ADD',\n                        payload: entries.map(processEntry as ProcessEntryFunc),\n                    });\n                }\n                return;\n            case 'LOAD':\n                await loadHistoryFromDB(\n                    (id) => postMessage({ type: 'REMOVE', payload: [id] }),\n                    (entry) => postMessage({ type: 'ADD', payload: [entry] }),\n                );\n                return;\n            case 'OPEN':\n                let entry: PaletteEntry | undefined = undefined;\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    entry = await loadItemFromDB(action.payload.timestamp);\n                }\n                postMessage({\n                    type: 'DISPLAY',\n                    payload: {\n                        entry,\n                        firstLoad: action.payload.firstLoad,\n                        updateHash: false,\n                    },\n                });\n                return;\n            case 'DELETE':\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    await deleteItemFromDB(action.payload.timestamp);\n                    postMessage({\n                        type: 'REMOVE',\n                        payload: [action.payload.timestamp],\n                    });\n                    if (action.payload.current) {\n                        const otherEntry = await openFirstItem();\n                        postMessage({\n                            type: 'DISPLAY',\n                            payload: {\n                                entry: otherEntry,\n                                firstLoad: false,\n                                updateHash: true,\n                            },\n                        });\n                    }\n                }\n                return;\n        }\n    } catch (err) {\n        postMessage({ type: 'ERROR', payload: String(err) });\n    }\n}\n","import { handleMessage } from './handle-message';\n\nexport declare var self: DedicatedWorkerGlobalScope;\n\nself.addEventListener('message', (evt) => handleMessage(evt.data, postMessage));\nhandleMessage({ type: 'LOAD', payload: undefined }, postMessage);\n"],"names":["idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","[object Object]","target","prop","receiver","IDBTransaction","get","objectStoreNames","undefined","objectStore","wrap","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","storeNames","tx","call","set","sort","transformCachableValue","value","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","processEntry","entry","timestamp","id","imgBlob","dataUri","header","data","split","mimeType","byteString","atob","buffer","ArrayBuffer","length","intBuffer","Uint8Array","i","charCodeAt","Blob","type","dataUriToBlob","imgSrc","URL","createObjectURL","colors","name","Date","toLocaleString","oldTraps","callback","white","black","EXAMPLES","vibrant","color","textColor","darkVibrant","lightVibrant","muted","darkMuted","lightMuted","dbPromise","version","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","openDB","createObjectStore","keyPath","saveItemsToDB","items","entries","all","map","item","blob","fetch","r","reader","FileReader","onload","onerror","readAsDataURL","blobToDataUri","url","protocol","revokeObjectURL","forEach","put","handleMessage","action","postMessage","console","log","payload","firstLoad","updateHash","exampleCb","historyCb","openCursor","cursor","hidden","key","loadHistoryFromDB","Number","isNaN","info","loadItemFromDB","delete","deleteItemFromDB","current","otherEntry","historyItems","getAll","exampleEntries","hiddenExamples","Set","filter","Array","from","values","find","example","openFirstItem","err","String","self","evt"],"mappings":"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"}