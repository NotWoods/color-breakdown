{"version":3,"file":"db-worker.js","sources":["../../node_modules/idb/build/esm/chunk.js","../../node_modules/idb/build/esm/index.js","../../src/db-worker/process-entry.ts","../../src/db-worker/examples.ts","../../src/db-worker/db.ts","../../src/revoke-object-url.ts","../../src/db-worker/handle-message.ts","../../src/db-worker/index.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    }).catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import { HistoryEntry, PaletteEntry } from '../entry';\n\n/**\n * Convert Data URI representing an image into a blob with the same data.\n * @see https://stackoverflow.com/questions/12168909/blob-from-dataurl\n */\nexport function dataUriToBlob(dataUri: string) {\n    const [header, data] = dataUri.split(',', 2);\n\n    // separate out the mime component\n    const mimeType = header.split(':', 2)[1].split(';', 1)[0];\n    // convert base64 to raw binary data held in a string\n    const byteString = atob(data);\n\n    // write the bytes of the string to an ArrayBuffer\n    const buffer = new ArrayBuffer(byteString.length);\n    const intBuffer = new Uint8Array(buffer); // create a view into the buffer\n    for (let i = 0; i < byteString.length; i++) {\n        intBuffer[i] = byteString.charCodeAt(i);\n    }\n\n    return new Blob([buffer], { type: mimeType });\n}\n\n/**\n * Convert blob to data uri\n * @throws DOMException if error when reading\n */\nexport function blobToDataUri(blob: Blob) {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result as string);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(blob);\n    });\n}\n\nexport function processEntry(entry: HistoryEntry): PaletteEntry;\nexport function processEntry(entry: undefined): undefined;\nexport function processEntry(\n    entry: HistoryEntry | undefined,\n): PaletteEntry | undefined;\nexport function processEntry(\n    entry: HistoryEntry | undefined,\n): PaletteEntry | undefined {\n    if (entry == undefined) {\n        return undefined;\n    }\n    const timestamp = entry.id as number;\n    const imgBlob = dataUriToBlob(entry.imgSrc);\n    return {\n        timestamp,\n        imgSrc: URL.createObjectURL(imgBlob),\n        colors: entry.colors,\n        name: entry.name || new Date(timestamp).toLocaleString(),\n    };\n}\n","import { PaletteEntry } from '../entry';\n\nconst white = '#FFFFFF';\nconst black = '#000000';\n\nconst example1: PaletteEntry = {\n    timestamp: 1,\n    imgSrc: 'img/demo/andrew-hughes-261571-unsplash.jpg',\n    name: 'Photo by Andrew Hughes on Unsplash',\n    colors: {\n        vibrant: { color: '#AE340E', textColor: white },\n        darkVibrant: { color: '#6C140C', textColor: white },\n        lightVibrant: { color: '#DACC9B', textColor: black },\n        muted: { color: '#9F805F', textColor: white },\n        darkMuted: { color: '#3B3945', textColor: white },\n        lightMuted: { color: '#DAD3B0', textColor: black },\n    },\n};\n\nconst example2: PaletteEntry = {\n    timestamp: 2,\n    imgSrc: 'img/demo/ever-wild-634729-unsplash.jpg',\n    name: 'Photo by ever wild on Unsplash',\n    colors: {\n        vibrant: { color: '#FBA409', textColor: black },\n        darkVibrant: { color: '#7C0404', textColor: white },\n        lightVibrant: { color: '#F9A250', textColor: black },\n        muted: { color: '#AC784C', textColor: white },\n        darkMuted: { color: '#8C6C44', textColor: white },\n        lightMuted: { color: '#BC987A', textColor: black },\n    },\n};\n\nconst example3: PaletteEntry = {\n    timestamp: 3,\n    imgSrc: 'img/demo/will-turner-1244879-unsplash.jpg',\n    name: 'Photo by Will Turner on Unsplash',\n    colors: {\n        vibrant: { color: '#1E8EE0', textColor: white },\n        darkVibrant: { color: '#061C2C', textColor: white },\n        lightVibrant: { color: '#8AC4EF', textColor: black },\n        muted: { color: '#777C80', textColor: white },\n        darkMuted: { color: '#253D4C', textColor: white },\n        lightMuted: { color: '#BBBCC4', textColor: black },\n    },\n};\n\nexport const examples: { [id: number]: PaletteEntry } = {\n    1: example1,\n    2: example2,\n    3: example3,\n};\n","import { DBSchema, openDB } from 'idb';\nimport { HistoryEntry, PaletteEntry } from '../entry';\nimport { revokeIfObjectUrl } from '../revoke-object-url';\nimport { blobToDataUri, processEntry } from './process-entry';\nimport { examples } from './examples';\n\ninterface ColorBreakdownDBSchema extends DBSchema {\n    history: {\n        key: number;\n        value: HistoryEntry;\n    };\n    example: {\n        key: number;\n        value: {\n            readonly id: number;\n            readonly hidden: true;\n        };\n    };\n}\n\nexport const dbPromise = openDB<ColorBreakdownDBSchema>('history-store', 2, {\n    upgrade(db, oldVersion) {\n        switch (oldVersion) {\n            case 0:\n                db.createObjectStore('history', { keyPath: 'id' });\n            // fall through\n            case 1:\n                db.createObjectStore('example', { keyPath: 'id' });\n            // fall through\n        }\n    },\n});\n\n/**\n * Loads a single history item for the main palette viewer\n */\nexport async function loadItemFromDB(\n    timestamp: number,\n): Promise<PaletteEntry | undefined> {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        const info = await db.get('example', timestamp);\n        const hidden = info != undefined ? info.hidden : false;\n        return hidden ? undefined : examples[timestamp] || undefined;\n    } else {\n        const item = await db.get('history', timestamp);\n        return processEntry(item);\n    }\n}\n\nexport async function openFirstItem(): Promise<PaletteEntry | undefined> {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    const historyItems = await tx.objectStore('history').getAll(undefined, 1);\n    if (historyItems.length > 0) {\n        return processEntry(historyItems[0]);\n    }\n\n    const exampleEntries = await tx.objectStore('example').getAll();\n    const hiddenExamples = new Set(\n        exampleEntries.filter(item => item.hidden).map(item => item.id),\n    );\n    const visibleExample = Object.values(examples).find(\n        example => !hiddenExamples.has(example.timestamp),\n    );\n    return visibleExample || undefined;\n}\n\n/**\n * Delete a history item with the given timestamp\n */\nexport async function deleteItemFromDB(timestamp: number) {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        await db.put('example', { id: timestamp, hidden: true });\n    } else {\n        await db.delete('history', timestamp);\n    }\n}\n\n/**\n * Load the history list.\n * @param callback Called on each iteration.\n */\nexport async function loadHistoryFromDB(\n    exampleCb: (id: number) => void,\n    historyCb: (entry: PaletteEntry) => void,\n) {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    await Promise.all([\n        tx\n            .objectStore('example')\n            .openCursor()\n            .then(async cursor => {\n                while (cursor) {\n                    if (cursor.value.hidden) {\n                        exampleCb(cursor.key);\n                    }\n                    cursor = await cursor.continue();\n                }\n            }),\n        tx\n            .objectStore('history')\n            .openCursor()\n            .then(async cursor => {\n                while (cursor) {\n                    historyCb(processEntry(cursor.value)!);\n                    cursor = await cursor.continue();\n                }\n            }),\n    ]);\n}\n\n/**\n * Save items to the database.\n * Items may have object URLs as `imgSrc` properties, and will be processed\n * into data URIs.\n */\nexport async function saveItemsToDB(\n    items: ReadonlyArray<PaletteEntry>,\n): Promise<HistoryEntry[]> {\n    // Need to process entries first due to IDB restrictions\n    const entries = await Promise.all(\n        items.map(async item => {\n            const blob = await fetch(item.imgSrc).then(r => r.blob());\n            const dataUri = await blobToDataUri(blob);\n            revokeIfObjectUrl(item.imgSrc);\n            return {\n                id: item.timestamp,\n                imgSrc: dataUri,\n                colors: item.colors,\n                name: item.name,\n            };\n        }),\n    );\n\n    const db = await dbPromise;\n    const { store, done } = await db.transaction('history', 'readwrite');\n    entries.forEach(entry => store.put(entry));\n    await done;\n\n    return entries;\n}\n","/**\n * Revoke a url if it is an object url.\n */\nexport function revokeIfObjectUrl(url: string) {\n    if (new URL(url).protocol === 'blob:') {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * When used as an `onload` listener for an image, this function will\n * revoke the image's source object url if it is an object url.\n */\nexport function revokeObjectUrlOnLoad(evt: Event) {\n    const img = evt.target as HTMLImageElement;\n    revokeIfObjectUrl(img.src);\n}\n","import { HistoryEntry, PaletteEntry } from '../entry';\nimport { UiAction } from '../page/handle-message';\nimport {\n    deleteItemFromDB,\n    loadHistoryFromDB,\n    loadItemFromDB,\n    openFirstItem,\n    saveItemsToDB,\n} from './db';\nimport { processEntry } from './process-entry';\n\ninterface SaveAction {\n    readonly type: 'SAVE';\n    readonly payload: ReadonlyArray<PaletteEntry>;\n}\n\ninterface LoadAction {\n    readonly type: 'LOAD';\n    readonly payload: undefined;\n}\n\ninterface OpenAction {\n    readonly type: 'OPEN';\n    readonly payload: {\n        readonly timestamp: number;\n        readonly firstLoad: boolean;\n    };\n}\n\ninterface DeleteAction {\n    readonly type: 'DELETE';\n    readonly payload: {\n        readonly timestamp: number;\n        readonly current: boolean;\n    };\n}\n\nexport type WorkerAction = SaveAction | LoadAction | OpenAction | DeleteAction;\ntype ProcessEntryFunc = (entry: HistoryEntry) => PaletteEntry;\n\nexport async function handleMessage(\n    action: WorkerAction,\n    postMessage: (msg: UiAction) => void,\n) {\n    console.log(action.type, action.payload);\n    try {\n        switch (action.type) {\n            case 'SAVE':\n                if (action.payload.length > 0) {\n                    const entries = await saveItemsToDB(action.payload);\n                    postMessage({\n                        type: 'DISPLAY',\n                        payload: {\n                            entry: processEntry(entries[0]),\n                            firstLoad: false,\n                            updateHash: true,\n                        },\n                    });\n                    postMessage({\n                        type: 'ADD',\n                        payload: entries.map(processEntry as ProcessEntryFunc),\n                    });\n                }\n                return;\n            case 'LOAD':\n                await loadHistoryFromDB(\n                    id => postMessage({ type: 'REMOVE', payload: [id] }),\n                    entry => postMessage({ type: 'ADD', payload: [entry] }),\n                );\n                return;\n            case 'OPEN':\n                let entry: PaletteEntry | undefined = undefined;\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    entry = await loadItemFromDB(action.payload.timestamp);\n                }\n                postMessage({\n                    type: 'DISPLAY',\n                    payload: {\n                        entry,\n                        firstLoad: action.payload.firstLoad,\n                        updateHash: false,\n                    },\n                });\n                return;\n            case 'DELETE':\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    await deleteItemFromDB(action.payload.timestamp);\n                    postMessage({\n                        type: 'REMOVE',\n                        payload: [action.payload.timestamp],\n                    });\n                    if (action.payload.current) {\n                        const otherEntry = await openFirstItem();\n                        postMessage({\n                            type: 'DISPLAY',\n                            payload: {\n                                entry: otherEntry,\n                                firstLoad: false,\n                                updateHash: true,\n                            },\n                        });\n                    }\n                }\n                return;\n        }\n    } catch (err) {\n        postMessage({ type: 'ERROR', payload: String(err) });\n    }\n}\n","import { handleMessage } from './handle-message';\n\nexport declare var self: DedicatedWorkerGlobalScope;\n\nself.addEventListener('message', evt => handleMessage(evt.data, postMessage));\nhandleMessage({ type: 'LOAD', payload: undefined }, postMessage);\n"],"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","[object Object]","target","prop","receiver","IDBTransaction","get","objectStoreNames","undefined","objectStore","wrap","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","storeNames","tx","call","set","sort","transformCachableValue","value","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","processEntry","entry","timestamp","id","imgBlob","dataUri","header","data","split","mimeType","byteString","atob","buffer","ArrayBuffer","length","intBuffer","Uint8Array","i","charCodeAt","Blob","type","dataUriToBlob","imgSrc","URL","createObjectURL","colors","name","Date","toLocaleString","oldTraps","callback","white","black","examples","1","vibrant","color","textColor","darkVibrant","lightVibrant","muted","darkMuted","lightMuted","2","3","dbPromise","version","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","openDB","createObjectStore","keyPath","saveItemsToDB","items","entries","all","map","item","blob","fetch","r","reader","FileReader","onload","onerror","readAsDataURL","blobToDataUri","url","protocol","revokeObjectURL","revokeIfObjectUrl","forEach","put","handleMessage","action","postMessage","console","log","payload","firstLoad","updateHash","exampleCb","historyCb","openCursor","cursor","hidden","key","loadHistoryFromDB","Number","isNaN","info","loadItemFromDB","delete","deleteItemFromDB","current","otherEntry","historyItems","getAll","exampleEntries","hiddenExamples","Set","filter","Object","values","find","example","openFirstItem","err","String","self","evt"],"mappings":"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"}