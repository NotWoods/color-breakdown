{"version":3,"file":"sw.js","sources":["../src/service-worker/index.ts"],"sourcesContent":["import hash from 'consts:hash';\n\nconst resources = [\n    './',\n    'index.html',\n    'css/base.css',\n    'css/desktop.css',\n    'css/new.css',\n    'css/palette.css',\n    'img/placeholder.svg',\n    'img/favicon/logo24.png',\n    'img/favicon/logo48.png',\n    'img/favicon/logo192.png',\n    'img/demo/andrew-hughes-261571-unsplash.jpg',\n    'img/demo/ever-wild-634729-unsplash.jpg',\n    'img/demo/will-turner-1244879-unsplash.jpg',\n    'js/chunk-b051499f.js',\n    'js/db-worker.js',\n    'js/index.js',\n    'lib/node-vibrant/vibrant.js',\n    'lib/node-vibrant/worker.js',\n    'lib/pwacompat.js',\n    'lib/shimport.js',\n];\n\nconst CACHE = `color-breakdown-${hash}`;\n\nexport declare var self: ServiceWorkerGlobalScope;\n\n// On install, cache some resources.\nself.addEventListener('install', event => {\n    // Ask the service worker to keep installing until the returning promise\n    // resolves.\n    event.waitUntil(precache());\n});\n\n// On activate, clean up old caches\nself.addEventListener('activate', event => {\n    event.waitUntil(clearOldCaches());\n});\n\n// On fetch, use cache but update the entry with the latest contents from the\n// server.\nself.addEventListener('fetch', event => {\n    event.respondWith(fromCache(event.request));\n});\n\n/**\n * Open a cache and use addAll() with an array of assets to add all of them to\n * the cache. Return a promise resolving when all the assets are added.\n */\nasync function precache() {\n    const cache = await caches.open(CACHE);\n    return cache.addAll(resources);\n}\n\n/**\n * Open the cache where the assets were stored and search for the requested\n * resource. Notice that in case of no matching, the promise still resolves\n * but it does with undefined as value.\n */\nasync function fromCache(request: Request) {\n    const matching = await caches.match(request);\n    if (matching) {\n        return matching;\n    }\n    try {\n        return await fetch(request);\n    } catch (err) {\n        if (new URL(request.url).hostname !== 'www.googletagmanager.com') {\n            throw new TypeError('Failed to fetch Google Analytics');\n        }\n        throw new TypeError(`Failed to fetch: ${request.url}`);\n    }\n}\n\nasync function clearOldCaches() {\n    const cacheNames = await caches.keys();\n    return Promise.all(\n        cacheNames\n            .filter(name => name !== CACHE)\n            .map(name => caches.delete(name)),\n    );\n}\n"],"names":["resources","CACHE","self","addEventListener","event","waitUntil","async","caches","open","addAll","precache","cacheNames","keys","Promise","all","filter","name","map","delete","clearOldCaches","respondWith","request","matching","match","fetch","err","URL","url","hostname","TypeError","fromCache"],"mappings":"AAEA,MAAMA,EAAY,CACd,KACA,aACA,eACA,kBACA,cACA,kBACA,sBACA,yBACA,yBACA,0BACA,6CACA,yCACA,4CACA,uBACA,kBACA,cACA,8BACA,6BACA,mBACA,mBAGEC,EAAQ,4BAKdC,KAAKC,iBAAiB,UAAWC,IAG7BA,EAAMC,UAkBVC,iBAEI,aADoBC,OAAOC,KAAKP,IACnBQ,OAAOT,GApBJU,MAIpBR,KAAKC,iBAAiB,WAAYC,IAC9BA,EAAMC,UAsCVC,iBACI,MAAMK,QAAmBJ,OAAOK,OAChC,OAAOC,QAAQC,IACXH,EACKI,OAAOC,GAAQA,IAASf,GACxBgB,IAAID,GAAQT,OAAOW,OAAOF,KA3CnBG,MAKpBjB,KAAKC,iBAAiB,QAASC,IAC3BA,EAAMgB,YAiBVd,eAAyBe,GACrB,MAAMC,QAAiBf,OAAOgB,MAAMF,GACpC,GAAIC,EACA,OAAOA,EAEX,IACI,aAAaE,MAAMH,GACrB,MAAOI,GACL,GAAsC,6BAAlC,IAAIC,IAAIL,EAAQM,KAAKC,SACrB,MAAM,IAAIC,UAAU,oCAExB,MAAM,IAAIA,UAAU,oBAAoBR,EAAQM,QA5BlCG,CAAU1B,EAAMiB"}